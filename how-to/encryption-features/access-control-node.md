---
description: >-
  Files can be pushed to the Lighthouse node with encryption using NodeJS to
  obtain Access Control, similar to the example below.
---

# ðŸšª Token Gating

<details>

<summary>Project Setup</summary>

**Step 1:** **Create a new Node.js application and initialize it:**

* Open your terminal or command prompt.
* Navigate to the desired directory where you want to create the application.
* Run the following command to create a new Node.js application

```bash
mkdir lighthouse-access-control-app
cd lighthouse-access-control-app
npm init -y
```

**Step 2:** **Install the required dependencies:**

```shell
npm install dotenv ethers @lighthouse-web3/sdk
```



</details>

**Step 3:** **Import the necessary dependencies and configure the environment variables in your Node.js application:**

_Note: In this example, we are using ES6 so we have to save the file as `filename.mjs` or define `"type": "module",` in the `package.json` file._

```javascript
import * as dotenv from 'dotenv'
dotenv.config()
import { ethers } from "ethers"
import lighthouse from '@lighthouse-web3/sdk'

const signAuthMessage = async (privateKey) => {
  const provider = new ethers.JsonRpcProvider()
  const signer = new ethers.Wallet(privateKey, provider)
  const messageRequested = (await lighthouse.getAuthMessage(signer.address)).data.message
  const signedMessage = await signer.signMessage(messageRequested)
  return signedMessage
}

const accessControl = async () => {
  try {
    // CID of encrypted file
    // CID is generated by uploading a file with encryption
    // Only the owner of the file can apply access conditions
    const cid = "Qma7Na9sEdeM6aQeu6bUFW54HktNnW2k8g226VunXBhrn7"
    const publicKey = "0xa3c960b3ba29367ecbcaf1430452c6cd7516f588"
    const privateKey = process.env.PRIVATE_KEY_WALLET1
    
    // Conditions to add
    const conditions = [
      {
        id: 1,
        chain: "Optimism",
        method: "getBlockNumber",
        standardContractType: "",
        returnValueTest: {
          comparator: ">=",
          value: "13349"
        },
      },
    ]

    // Aggregator is what kind of operation to apply to access conditions
    // Suppose there are two conditions then you can apply ([1] and [2]), ([1] or [2]), !([1] and [2]).
    const aggregator = "([1])"

    const signedMessage = await signAuthMessage(privateKey)
    /*
      accessCondition(publicKey, cid, signedMessage, conditions, aggregator)
        Parameters:
          publicKey: owner's public key
          CID: CID of the file to apply access control on
          signedMessage: message signed by the owner of publicKey
          conditions: access conditions in the specified format
          aggregator: aggregator to apply conditions
    */
    const response = await lighthouse.applyAccessCondition(
      publicKey,
      cid,
      signedMessage,
      conditions,
      aggregator
    )

    // Display response
    console.log(response)
  } catch (error) {
    console.log(error)
  }
}

const getFileEncryptionKey = async () => {
  try {
    // Get key back after passing access control condition
    const cid = 'YOUR_CID' // Example: "Qma7Na9sEdeM6aQeu6bUFW54HktNnW2k8g226VunXBhrn7";
    const publicKey = 'YOUR_PUBLIC_KEY' // Example: "0x969e19A952A9aeF004e4F711eE481D72A59470B1";
    const privateKey = process.env.PRIVATE_KEY_WALLET2

    const signedMessage = await signAuthMessage(privateKey)
    /*
      fetchEncryptionKey(cid, publicKey, signedMessage)
        Parameters:
          cid: CID of the file
          publicKey: your public key
          signedMessage: message signed by the owner of the public key
    */
    const key = await lighthouse.fetchEncryptionKey(
      cid,
      publicKey,
      signedMessage
    )
    console.log(key)
  } catch (error) {
    console.log(error)
  }
}

accessControl()
```

Expected Response (for accessControl function):

```bash
{
  data: {
    cid: 'Qma7Na9sEdeM6aQeu6bUFW54HktNnW2k8g226VunXBhrn7',
    status: 'Success'
  }
}
```

Expected Response (for getFileEncryptionKey function):

```bash
{
  data: {
    key: '18475nf54a37294f538t4c83ba67e0c5e11fds0fcaa2507cg8539aaff79c5d82'
  }
}
```

**Step 4:** **Customize the code:**

* Replace `YOUR_CID` with the actual CID of the file you want to apply access control on.
* Replace `YOUR_PUBLIC_KEY` with your own public key.
* Update the conditions and aggregator variables according to your access control requirements.

**Step 5:** **Configure the Private Keys:**

* Create a .env file in your project's root directory.
* Add the following content to the .env file:

```makefile
PRIVATE_KEY_WALLET1=YOUR_PRIVATE_KEY_WALLET1
PRIVATE_KEY_WALLET2=YOUR_PRIVATE_KEY_WALLET2
```

* Replace `YOUR_PRIVATE_KEY_WALLET1` with your own private key corresponding to the public key used for Wallet 1 (Can be obtained from the wallet.json file made while [creating a wallet](https://docs.lighthouse.storage/lighthouse-1/cli-tool/cli-commands/create-wallet)).
* Replace `YOUR_PRIVATE_KEY_WALLET2` with your own private key corresponding to the public key used for Wallet 2.

**Step 6:** **Run the Node.js application to upload the file:**

* In the terminal, while in the `lighthouse-access-control-app` directory, run the following command:

```shell
node app.js
```

* The response from the access control process will be displayed in the console, indicating the status of the operation.

**Note:** Ensure that you have the correct CID, private keys, and necessary configurations set before running the application.

With this code, you can apply access control to a file on the Lighthouse node using Node.js.

### Supported Chains

Mainnet: Ethereum (ethereum), Filecoin, Polygon (polygon), Solana (solana), Base, Fantom (fantom), Optimism (optimism), BSC (binance chain), AVAX, Fuji, Forma, Destra, Radix\_Mainnet\
Testnet: Mumbai (polygon-testnet), Filecoin\_Testnet, Base\_Testnet, Shardeum\_Lib1, Shardeum\_Lib2, Calibration, Goerli, BSCTest (binance-testnet), FantomTest, Rinkeby, OptimismGoerli, OptimismKovan, Forma Testnet (Forma\_Sketchpad), Destra\_Testnet, Zircuit\_Testnet, Scroll\_Testnet, Abstract\_Testnet\
**Note: N**ame is not case sensitive.
